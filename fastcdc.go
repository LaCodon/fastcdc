package fastcdc

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"iter"
)

const (
	defaultMinSize    int = 8 * 1024   // 8KB
	defaultNormalSize     = 64 * 1024  // 64KB
	defaultMaxSize        = 128 * 1024 // 128KB
	defaultMaskS          = (1 << 18) - 1
	defaultMaskL          = (1 << 14) - 1
)

type Chunk struct {
	Offset int
	Size   int
	Data   []byte
}

type FastCDC struct {
	r *bufio.Reader

	minSize    int
	normalSize int
	maxSize    int
	maskS      int
	maskL      int

	lastOffset int
	lastSize   int
}

type Option func(f *FastCDC)

func WithMinSizeBytes(minSize int) Option {
	return func(f *FastCDC) {
		f.minSize = minSize
	}
}

func WithNormalSizeBytes(normalSize int) Option {
	return func(f *FastCDC) {
		f.normalSize = normalSize
	}
}

func WithMaxSizeBytes(maxSize int) Option {
	return func(f *FastCDC) {
		f.maxSize = maxSize
	}
}

func WithMaskS(maskS int) Option {
	return func(f *FastCDC) {
		f.maskS = maskS
	}
}

func WithMaskL(maskL int) Option {
	return func(f *FastCDC) {
		f.maskL = maskL
	}
}

func New(
	source io.Reader,
	opts ...Option,
) *FastCDC {
	f := &FastCDC{
		r: nil,

		minSize:    defaultMinSize,
		normalSize: defaultNormalSize,
		maxSize:    defaultMaxSize,
		maskS:      defaultMaskS,
		maskL:      defaultMaskL,

		lastOffset: 0,
		lastSize:   0,
	}

	for _, opt := range opts {
		opt(f)
	}

	f.r = bufio.NewReaderSize(source, f.maxSize*3)

	return f
}

func (f *FastCDC) NextChunk() (Chunk, error) {
	return f.nextChunk()
}

func (f *FastCDC) Chunks() iter.Seq2[Chunk, error] {
	return func(yield func(Chunk, error) bool) {
		for {
			chunk, err := f.nextChunk()
			switch {
			case errors.Is(err, io.EOF):
				return
			case err != nil:
				yield(Chunk{}, err)
				return
			}

			if !yield(chunk, nil) {
				return
			}
		}
	}
}

func (f *FastCDC) nextChunk() (Chunk, error) {
	buf, err := f.nextWindow()
	switch {
	case errors.Is(err, io.EOF):
		return Chunk{}, err
	case err != nil:
		return Chunk{}, fmt.Errorf("fill buffer: %w", err)
	}

	cutPoint := f.nextCutPoint(buf)
	chunkData := f.readChunk(buf[:cutPoint])

	chunk := Chunk{
		Offset: f.lastOffset + f.lastSize,
		Size:   len(chunkData),
		Data:   chunkData,
	}

	f.lastOffset = chunk.Offset
	f.lastSize = chunk.Size

	return chunk, nil
}

func (f *FastCDC) nextWindow() ([]byte, error) {
	window, err := f.r.Peek(int(f.maxSize))
	if len(window) > 0 {
		return window, nil
	}

	return nil, err
}

func (f *FastCDC) nextCutPoint(buf []byte) int {
	if len(buf) <= f.minSize {
		return len(buf)
	}

	normalSize := min(len(buf), f.normalSize)

	var fp, i int = 0, 0

	for ; i < f.minSize; i++ {
		fp = (fp << 1) + gear[buf[i]]
	}

	for ; i < normalSize; i++ {
		fp = (fp << 1) + gear[buf[i]]
		if fp&f.maskS == 0 {
			return i + 1
		}
	}

	for ; i < len(buf); i++ {
		fp = (fp << 1) + gear[buf[i]]
		if fp&f.maskL == 0 {
			return i + 1
		}
	}

	return i
}

func (f *FastCDC) readChunk(buf []byte) []byte {
	_, err := f.r.Read(buf)
	if err != nil {
		// this should never happen
		panic(fmt.Sprintf("Tried to read more than peaked before: %s", err.Error()))
	}

	return buf
}

var gear [256]int = [256]int{
	0x5E10AB99F5524BD9, 0x6637D0259DC3968C, 0x2E67BA0324378BEE, 0x2ABF5CE097FB1461, 0x77054AB84CCBE73D, 0x2E81BA2DC90090AE, 0x43D426D88B959FE5, 0x415C486609B616A1,
	0x27C497B99AED99E4, 0x3AD8CAE81F891810, 0x6D16F879911986ED, 0x680E2DF5CBC27587, 0x74E0516E3E003EAA, 0x4881648BE6CBD11F, 0x3D687FAEFDFF2D27, 0x7B5AD91C4C783469,
	0x5686917F0BED7251, 0x725C20E02BD07FA2, 0x3B16D7603D5F36F5, 0x288849EB7D1F956B, 0x600BEDB381FCF066, 0x24A633A7C3847754, 0x4E3E87AA525BDE92, 0x63C337DDF006B19C,
	0x3BBEEE3787E3062B, 0x79C8FF8747629A18, 0x1F369D072E1DBA56, 0x3DF60155A648F082, 0x7DB7752BD7530715, 0x38DAC5FB3775AD5D, 0x079C690B20606C90, 0x754A66F436A829B6,
	0x7B16ED57BAFF3B56, 0x04B74D1BC2ABF6BE, 0x52ABB52ABFD69FE2, 0x797F2B6C4D3D3630, 0x31D99FF99CE9BE55, 0x25B9B87C20C6F4C5, 0x46E252B1339F7E3D, 0x13CF89FEA9A7E012,
	0x14072C9947EAAD93, 0x21B35F003A4CF4DD, 0x316415C7137C6415, 0x27844F080158766E, 0x31015EC3B4D0817F, 0x3D5D9F414E1DAF6A, 0x0DD79CFC903CE660, 0x18EAC47E294E379C,
	0x64500FB4A2029917, 0x5C0A36B0A74A8835, 0x43D018E645238A7B, 0x700A33BD8F4634B0, 0x4DF164B284A60356, 0x35B115B450FACF6E, 0x3223922043EF9538, 0x1F092B0D053D7426,
	0x327349369CA104A0, 0x68FB284702516501, 0x402E3BB740F2B6A7, 0x6BDFAAC58FF5FCA6, 0x0238BBB7F7147CC6, 0x3756C0421192ACB7, 0x6AFE605330141499, 0x0752CD5967487A31,
	0x5F47EA103C3356BA, 0x0584399259AA9277, 0x5613065D53695C5A, 0x31C09177E362B387, 0x2A19B5ECD863B287, 0x3E7C858083277DEC, 0x1F1EA1504343798B, 0x2698BF1ADEA693D1,
	0x36C1F88D1F8F6BDA, 0x66E833F2194C4BE0, 0x764E1652302B183C, 0x6FCBD913013CD81A, 0x601826AB0A2FE970, 0x6D0965E7D15C7C74, 0x5084A9F055BF86AB, 0x5746F5E6E630DA7F,
	0x0C4B18133F010A2F, 0x04ECF72BD83C8560, 0x71034CDC90C8E110, 0x1FE4DE43D22F67B8, 0x2A28278153497304, 0x62591941CC6B4A0E, 0x6048C53C8953ED09, 0x0DCA5598269FCE48,
	0x6A56B0ACA07116D4, 0x09DC5EC27374005B, 0x06230295A9A227BB, 0x7BB64921A1905651, 0x7033D80E99999F39, 0x0A6CBAF42C44F8E9, 0x12200BDBA4705080, 0x7DC00E3E0D081EDB,
	0x230FA13E62756826, 0x31CDDA74EA7B0ECB, 0x4494DD3479166177, 0x29744E0447721D0B, 0x6D17A64BF7CEB447, 0x4A59F1956C5004EA, 0x172411677CB484FB, 0x124F3006A1CD3A09,
	0x2A340848FC357EF3, 0x7C72352889E5DA38, 0x2D99401D698D6982, 0x6882D5A920D16508, 0x1A822E1FC9D20CAD, 0x386CF9A1608B9A0D, 0x283BE935E16DBC3D, 0x0C14222DDC5CF0ED,
	0x4FA94C2B71418AD6, 0x32F8F8F476725038, 0x53F57CB861CDC976, 0x50B401005C645552, 0x42319DAF1186CA8E, 0x251FA151CAEE0F1E, 0x53263C15C93933B3, 0x2F3E566EC839DCC6,
	0x53487BC69905D3C9, 0x134F17EF44B7446D, 0x3F34B927B916B324, 0x4CB834DE3BB9024D, 0x0EA2E6BF96568B5F, 0x2807B67FA7F24553, 0x4D5EF36A79931D1C, 0x42FEA02BC5CBF7DF,
	0x01A75BABF37A34C3, 0x3C0CAA9C25761A9B, 0x0AC940BDB7F60389, 0x5524BCC73F311D13, 0x6BB699EFBFCA8204, 0x5DB393EC739589C6, 0x0265EA39BA19E32A, 0x1ED15B2200CDA8B3,
	0x67C6B5F9859837CA, 0x6E929896DF44B025, 0x16EA91D5E635ABCD, 0x24F24D51839983AD, 0x1688B6E7603E0063, 0x3B39F8598C9AA482, 0x3BA954B127660005, 0x09B1790775420E81,
	0x5845659E1D511560, 0x1739653B931546D6, 0x206242FF7D580CA8, 0x5B5D255D74C6BE7F, 0x037209D11ECBD1D6, 0x5161C5B210C91383, 0x3C64B2645F3CB90A, 0x461B67DF63129AEE,
	0x72F3E0A23B0A1C20, 0x26CD8C4389DC099D, 0x3ABCEE22AA87BBBC, 0x3B98433E70261903, 0x3C9954C11D493DC2, 0x373AF65FE6316146, 0x54B0121D6F600285, 0x721666F3F31BC9CA,
	0x2CBAA41782FEC39B, 0x1DCA28BE87AE9B7A, 0x0E06B0EE3F8AAC8B, 0x2FA3F19882131DCD, 0x400879348B38FB8D, 0x6509D7C51A3B3151, 0x549D7C1D3569F69A, 0x54E48DCC7C9A7E7D,
	0x0A519CD0E9A97F14, 0x7957C32BD1638A6C, 0x1CBB7F0FD646677B, 0x10875F74D359950C, 0x5898A78409384F6E, 0x2A21A6CE60D9EDD3, 0x3F7A3B8FCBCD1519, 0x4FD8368C6D1A5912,
	0x376C766E9460C388, 0x447850132E1F159F, 0x32FA5F52014D9F4D, 0x597F4CBC525535C4, 0x5FF98065F18EBDD4, 0x207C608651055D2F, 0x055DE13E20D1A788, 0x3E6A4BB53F795DF5,
	0x3F9AEB1A5AC120E6, 0x2128344075EB9519, 0x37A5BCAF8370236E, 0x5B8A7689FF10FEBE, 0x4430B1EEC8D766FD, 0x5F8ADB0474DAB721, 0x1029A4EC4FCA7C49, 0x68D2BD2183BC83C4,
	0x7DBA6BCA8519EB99, 0x6D92DA30579B8B24, 0x565BC2507AB49773, 0x22EB61D3225F3797, 0x4CBA7792A44F45B3, 0x0702F525D8C4A594, 0x2BC6015854F1983E, 0x2C46D68BA790689A,
	0x1DB891225151AA9E, 0x3E616226F02E1E14, 0x4B57C119CAB59F16, 0x350A71571516A495, 0x64877DDF1A541D2C, 0x48C63713B16F773E, 0x5E7746B0C7A27906, 0x56C84A006E860DB3,
	0x76F0B2F2E763B67B, 0x430355B2EEB51A6F, 0x210BBA301C75CC54, 0x34AB2D04104524CD, 0x243D196B3CAAC60C, 0x574A7C3EF02621C6, 0x70597998314DB5C3, 0x5029FD09E4D3D1F0,
	0x4C6C9A58FD1AE3C0, 0x653CB43F15EA6F35, 0x324E071376CF880E, 0x6507C6DEF5D7B49D, 0x46B13BFE11C0B1AE, 0x47C262FE44160AF4, 0x3DA301FC5DDB6C48, 0x5D6F1C74B6460C60,
	0x29F66B61267E6298, 0x1C21CD99D4864E3F, 0x5CD7216DCC784B05, 0x72A5D4918D212DAF, 0x231518CA6E7E0D0E, 0x15B66041B9331C32, 0x48C10F3259C69EC9, 0x66F096616CCA5CD0,
	0x04480D556921CB92, 0x51878C13900B224D, 0x56E9E7033BD7CC41, 0x27DD000E031208CC, 0x68CA73056CA1441B, 0x0B8EAC6662C75E31, 0x14C42CC8EFAA61F1, 0x3CD20B73F40F6CCE,
	0x2A4369A58DC5C990, 0x3DC1B922207C716E, 0x7004BF39D0ADDF5A, 0x1A4105483C7885A9, 0x2A4DFEE4D8CAAFBD, 0x49EB34A4F6008E68, 0x74F3686219C4CA2F, 0x43B2CC3E285032C8,
	0x37B0A878D33852AA, 0x294FA91B592B9F99, 0x74CBC0915D3FAFDE, 0x38D1FE46913B6EE3, 0x478E3E4AB436DBA6, 0x43F3FAB58B63B5CD, 0x430BECC9642E5CBE, 0x489196CCD99F06DF,
}
